# MCP SDK Upgrade Plan

**Objective:** Replace `github.com/mark3labs/mcp-go` with official `github.com/modelcontextprotocol/go-sdk` and implement enhanced tool call tracking with LLM-API integration.

---

## Phase 1: Library Migration Assessment

### 1.1 Current State Analysis âœ“
**Files using mark3labs/mcp-go:**
- `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/mcp_route.go`
- `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/serper_mcp.go`
- `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/provider_mcp.go`
- `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/sandboxfusion_mcp.go`
- `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/memory_mcp.go`
- `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/context_utils.go`
- `services/mcp-tools/utils/mcp/options.go`
- `services/mcp-tools/go.mod` (dependency declaration)

**Additional references to mark3labs/mcp-go (docs/metadata):**
- `services/mcp-tools/go.sum`
- `services/mcp-tools/README.md`
- `services/mcp-tools/mcp-providers.md`
- `docs/architecture/README.md`
- `CHANGELOG.md`

**Current Architecture:**

There are **TWO SEPARATE FLOWS** for tool execution:

### Flow 1: Direct LLM-API (Frontend-Orchestrated)
```
1. Frontend â†’ LLM-API (chat request)
2. LLM-API â†’ Frontend (SSE: tool_calls needed)
3. Frontend â†’ MCP-Tools (execute tools directly via /v1/mcp endpoint)
4. MCP-Tools â†’ Frontend (tool results)
5. Frontend â†’ LLM-API (submit tool results as new messages)
6. LLM-API â†’ Frontend (final response or more tool_calls)
```
**Characteristics:**
- Frontend orchestrates the tool execution loop
- LLM-API streams tool_calls back to frontend
- Frontend is responsible for calling MCP-Tools
- Frontend sends tool results back to LLM-API as new messages
- **Tool Call ID:** Generated by LLM, passed through frontend, must be restored on conversation reload

### Flow 2: Response-API (Backend-Orchestrated)
```
1. Frontend/External â†’ Response-API (chat request)
2. Response-API â†’ LLM-API (chat request)
3. LLM-API â†’ Response-API (tool_calls needed)
4. Response-API â†’ MCP-Tools (execute tools via tool orchestrator)
5. MCP-Tools â†’ Response-API (tool results)
6. Response-API â†’ LLM-API (submit tool results)
7. Loop 2-6 until final response (max depth check)
8. Response-API â†’ Frontend/External (final response)
```
**Characteristics:**
- Response-API's Orchestrator handles the entire tool execution loop
- No frontend involvement in tool execution
- Supports streaming and background execution
- **Tool Call ID:** Generated by LLM, used internally for correlation, must propagate through orchestrator to MCP-Tools

**Key Imports:**
- `mcpserver "github.com/mark3labs/mcp-go/server"`
- `mcpgo "github.com/mark3labs/mcp-go/mcp"`

### 1.2 Official SDK Analysis
**Package Structure:**
- `github.com/modelcontextprotocol/go-sdk/mcp` - Primary client/server APIs
- `github.com/modelcontextprotocol/go-sdk/jsonrpc` - Custom transports
- `github.com/modelcontextprotocol/go-sdk/auth` - OAuth primitives
- Latest version: v1.1.0

**Key Differences:**
| mark3labs/mcp-go | Official go-sdk | Notes |
|------------------|-----------------|-------|
| `mcpserver.NewMCPServer()` | `mcp.NewServer()` | Different constructor |
| `server.AddTool()` | `mcp.AddTool(server, ...)` | Function vs method |
| `mcpgo.CallToolRequest` | `mcp.CallToolRequest` | Type structure may differ |
| `mcpserver.NewStreamableHTTPServer()` | Custom HTTP handler needed | No built-in HTTP SSE server |
| Options pattern: `WithToolCapabilities()` | `&mcp.Implementation{}` | Different config approach |

### Phase 1 Checklist
- [x] Confirm inventory of `mark3labs/mcp-go` usage matches current file paths (added `utils/mcp/options.go` + docs references).
- [x] Document both tool execution flows and ensure compatibility targets are clear (retain dual-flow support during migration).
- [x] Validate official SDK API differences (constructors, tool registration, request shapes; targeting go-sdk v1.1.0).
- [x] Decide HTTP/SSE transport approach and guardrails for go-sdk (custom HTTP handler + SSE streaming via jsonrpc helpers; strict method guard/heartbeats).
- [x] Record open risks/questions to resolve before starting migration work.

**Phase 1 Open Risks/Questions:**
- Confirm `mcp.CallToolRequest` exact shape (`Params.Arguments` type and nil-safety) in go-sdk v1.1.0 to finalize context helpers.
- Validate go-sdk HTTP transport patterns for long-lived SSE (ensure `jsonrpc` stream helper supports concurrent requests and heartbeats).
- Check compatibility of existing clients with go-sdk `initialize/ping` semantics and any required capability announcements.
- Decide how to handle legacy docs referencing mark3labs (update or deprecate).

---

## Phase 2: Migration Strategy

### 2.1 Dependency Update
**Files to modify:**
- [ ] `services/mcp-tools/go.mod`
  ```diff
  - github.com/mark3labs/mcp-go v0.43.0
  + github.com/modelcontextprotocol/go-sdk v1.1.0
  ```

**Action:**
```bash
cd services/mcp-tools
go get github.com/modelcontextprotocol/go-sdk@v1.1.0
go mod tidy
```

### 2.2 Import Updates
**Pattern to replace across all files:**
```diff
- mcpserver "github.com/mark3labs/mcp-go/server"
- mcpgo "github.com/mark3labs/mcp-go/mcp"
+ "github.com/modelcontextprotocol/go-sdk/mcp"
```

### 2.3 Server Initialization Migration
**File:** `mcp_route.go`

**Current:**
```go
server := mcpserver.NewMCPServer("menlo-platform", "1.0.0",
    mcpserver.WithToolCapabilities(true),
    mcpserver.WithRecovery(),
)
```

**New:**
```go
impl := &mcp.Implementation{
    Name:    "menlo-platform",
    Version: "1.0.0",
}
server := mcp.NewServer(impl, nil)
// Note: Official SDK handles tool capabilities implicitly when tools are added
```
- Action item: confirm constructor options (middlewares, logging) available in v1.1.0 before wiring

### 2.4 Tool Registration Migration
**Current pattern:**
```go
server.AddTool(
    mcpgo.NewTool("google_search", options...),
    func(ctx context.Context, req mcpgo.CallToolRequest) (*mcpgo.CallToolResult, error) {
        // handler
    },
)
```

**New pattern (per go-sdk v1.1.0):**
- Handler signature: `func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error)`
- Parse typed input inside handler (e.g., mapstructure/json decode `req.Params.Arguments`)
- Keep `mcp.Tool` metadata for name/description; register via `mcp.AddTool(server, tool, handler)`
- Action item: confirm actual `CallToolRequest` shape from SDK before edits (expected: `Params` with `Name string` and `Arguments map[string]any`)

### 2.5 HTTP Transport Implementation
**Decision:** Keep HTTP + SSE (to match current behavior) but re-implement using go-sdk `jsonrpc` helpers instead of `NewStreamableHTTPServer`.

**Supported Methods (v1):**
- `initialize` - Client handshake
- `ping` - Health check
- `tools/list` - Return registered tools from registry
- `tools/call` - Execute tool and return result

**Plan:**
1) Study go-sdk http/stdio examples to confirm the recommended server entrypoint (e.g., wrapping an `io.ReadWriteCloser` and calling server transport helper).
2) Implement an HTTP handler that:
   - Accepts a long-lived POST at `/mcp`
   - Bridges `r.Body`/`ResponseWriter` to the SDK transport (no hand-rolled JSON-RPC parsing)
   - Streams responses as SSE (`data: ...\n\n`) with `Flush()`
   - Adds heartbeat/ping frames (~30s interval) and request timeouts to avoid stale connections
   - Preserves JSON-RPC ids for multiplexing multiple tool calls on one stream
   - Adds **strict method guard**: reject unknown methods with MCP-compliant `-32601` error
   - Keeps stateless behavior (no sessions required)
3) Add integration test for a single tool over HTTP SSE: happy path, client disconnect, invalid method/params.

### Phase 2 Checklist
- [x] Update `services/mcp-tools/go.mod` to `github.com/modelcontextprotocol/go-sdk v1.1.0` and run `go mod tidy`.
- [x] Replace `mark3labs/mcp-go` imports with `github.com/modelcontextprotocol/go-sdk/mcp`.
- [x] Migrate server initialization to `mcp.NewServer` with `mcp.Implementation`.
- [x] Migrate tool registration handlers to the new request/response types (Serper, SandboxFusion, Memory, Provider).
- [x] Implement HTTP/SSE transport via go-sdk `NewStreamableHTTPHandler` with stateless mode; method guard retained.
- [x] Update context handling to new request shape by using typed handlers (no legacy options helper; removed `utils/mcp/options.go`).

### 2.6 Context Extraction Updates
**File:** `context_utils.go`

**Current:**
```go
func extractContextString(req mcpgo.CallToolRequest, key string) string {
    args := req.GetArguments()
    if args == nil {
        return ""
    }
    if val, ok := args[key]; ok {
        if str, ok := val.(string); ok {
            return str
        }
    }
    return ""
}
```

**New (after verifying CallToolRequest structure):**
```go
func extractContextString(req *mcp.CallToolRequest, key string) string {
    if req == nil || req.Params == nil || req.Params.Arguments == nil {
        return ""
    }
    if val, ok := req.Params.Arguments[key]; ok {
        if str, ok := val.(string); ok {
            return str
        }
    }
    return ""
}
```
Add helper `extractAllContext()` that returns a map for logging; normalize keys (`tool_call_id`, `request_id`, `conversation_id`, `user_id`) from both orchestrator and frontend casing.

---

## Phase 3: Enhanced Tool Call Tracking

### 3.1 Problem Statement
**Current Issues:**
- Tool results not properly correlated with tool calls when conversations are reloaded
- `tool_call_id` context not consistently propagated
- Multiple parallel tool results may be lost (only last message stored)

**Root Causes:**
1. LLM-API `itemToMessage()` didn't restore `tool_calls` and `tool_call_id` âœ… FIXED
2. LLM-API only stored last input message, dropping multiple tool results âœ… FIXED
3. Need explicit tool_call_id injection into MCP tool execution context

### 3.2 Context Propagation Enhancement

#### Flow 1: Frontend-Orchestrated (Direct LLM-API)
```
LLM generates tool_call â†’ tool_call_id = "call_abc123"
    â†“
LLM-API â†’ Frontend (SSE stream with tool_calls)
    â†“
Frontend stores tool_call_id from LLM response
    â†“
Frontend â†’ MCP-Tools (directly to /v1/mcp, could add X-Tool-Call-ID header)
    â†“
MCP-Tools executes tool (logs tool_call_id if provided)
    â†“
MCP-Tools â†’ Frontend (tool result)
    â†“
Frontend â†’ LLM-API (new message with role=tool, tool_call_id in message)
    â†“
LLM-API stores message with tool_call_id âœ… FIXED
    â†“
On reload: LLM-API restores tool_call_id to messages âœ… FIXED
```

**Status:** âœ… MOSTLY FIXED
- LLM-API now correctly stores and restores tool_call_id
- LLM-API now stores ALL tool result messages (not just last one)
- Frontend already sends tool_call_id in message content
- **Optional Enhancement:** Frontend could send X-Tool-Call-ID header to MCP-Tools for better tracing

#### Flow 2: Response-API Orchestrated
```
Frontend â†’ Response-API (chat request with optional X-Request-ID header)
    â†“
Response-API extracts/generates request_id âœ… IMPLEMENTED
    â†“
Response-API â†’ LLM-API (with request context)
    â†“
LLM-API â†’ Response-API (tool_calls with tool_call_id)
    â†“
Response-API Orchestrator receives tool_calls
    â†“
For each tool_call:
  - Orchestrator builds CallRequest{ToolCallID, RequestID, ConversationID, UserID}
  - Orchestrator â†’ MCP Client â†’ MCP-Tools
  - MCP-Tools receives context fields in arguments
  - MCP-Tools logs with tool_call_id for tracing
  - MCP-Tools â†’ Response-API (tool result)
  - Orchestrator creates tool result message with tool_call_id
    â†“
Response-API â†’ LLM-API (tool result messages with tool_call_id)
    â†“
LLM-API stores with tool_call_id âœ… FIXED
```

**Status:** ðŸ”„ PARTIALLY IMPLEMENTED
- âœ… Request ID extraction in response_handler.go
- âœ… Orchestrator passes RequestID, ConversationID, UserID to MCP
- âœ… MCP Client builds CallRequest with context
- âœ… LLM-API stores and restores tool_call_id
- âŒ **MISSING:** MCP-Tools doesn't extract tool_call_id from arguments for logging
- âŒ **MISSING:** Response-API doesn't extract X-Tool-Call-ID header (only X-Request-ID)

### Phase 3 Checklist
- [ ] Pass `tool_call_id` through Response-API MCP client payloads and logs.
- [ ] Merge `request_id`, `conversation_id`, `user_id`, `tool_call_id` into MCP arguments.
- [ ] Update MCP-Tools context extraction helpers for the official SDK request shape.
- [ ] Update all MCP tool handlers to use the shared context extractor and log full context.
- [ ] (Optional) Handle `X-Tool-Call-ID` header in MCP entrypoint for frontend-orchestrated flow.

### 3.3 Implementation Tasks

#### Task 3.3.1: Response-API Tool Call ID Logging (Response-API Flow Only)
**File:** `jan-server/services/response-api/internal/infrastructure/mcp/client.go`

**Current (Phase 3 implementation):**
```go
func (c *Client) CallTool(ctx context.Context, req CallRequest) (*CallResult, error) {
    // Extract context for logging
    requestID := response.RequestIDFromContext(ctx)
    conversationID := response.ConversationIDFromContext(ctx)
    userID := response.UserIDFromContext(ctx)
    
    // Build JSON-RPC payload
    payload := map[string]interface{}{
        "jsonrpc": "2.0",
        "method":  "tools/call",
        "id":      1,
        "params": map[string]interface{}{
            "name":      req.Name,
            "arguments": mergeContextIntoArguments(req.Arguments, req.RequestID, req.ConversationID, req.UserID),
        },
    }
    
    log.Info().
        Str("tool", req.Name).
        Str("request_id", requestID).
        Msg("Calling MCP tool")
    // ...
}
```

**Enhancement:**
```go
func (c *Client) CallTool(ctx context.Context, req CallRequest) (*CallResult, error) {
    // Extract ALL context fields including tool_call_id from request
    requestID := response.RequestIDFromContext(ctx)
    conversationID := response.ConversationIDFromContext(ctx)
    userID := response.UserIDFromContext(ctx)
    
    // Build JSON-RPC payload with tool_call_id in arguments
    payload := map[string]interface{}{
        "jsonrpc": "2.0",
        "method":  "tools/call",
        "id":      1,
        "params": map[string]interface{}{
            "name": req.Name,
            "arguments": mergeContextIntoArguments(
                req.Arguments,
                req.RequestID,
                req.ConversationID,
                req.UserID,
                req.ToolCallID, // NEW: Pass tool_call_id
            ),
        },
    }
    
    // Enhanced logging with tool_call_id
    log.Info().
        Str("tool", req.Name).
        Str("tool_call_id", req.ToolCallID). // NEW
        Str("request_id", requestID).
        Str("conversation_id", conversationID).
        Str("user_id", userID).
        Msg("Calling MCP tool")
    // ...
}
```

**Update mergeContextIntoArguments:**
```go
func mergeContextIntoArguments(args map[string]interface{}, requestID, conversationID, userID, toolCallID string) map[string]interface{} {
    merged := make(map[string]interface{})
    for k, v := range args {
        merged[k] = v
    }
    if requestID != "" {
        merged["request_id"] = requestID
    }
    if conversationID != "" {
        merged["conversation_id"] = conversationID
    }
    if userID != "" {
        merged["user_id"] = userID
    }
    if toolCallID != "" {
        merged["tool_call_id"] = toolCallID // NEW
    }
    return merged
}
```

**Note:** CallRequest already has ToolCallID field (set by Orchestrator), just need to use it in logging and merge function.
Add tests/trace to confirm ToolCallID is set for both streaming and non-streaming call paths.

#### Task 3.3.2: MCP-Tools Context Extraction (Both Flows)
**File:** `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/context_utils.go`

**Current:**
```go
func extractContextString(req mcpgo.CallToolRequest, key string) string {
    args := req.GetArguments()
    if args == nil {
        return ""
    }
    if val, ok := args[key]; ok {
        if str, ok := val.(string); ok {
            return str
        }
    }
    return ""
}
```

**Enhancement:**
```go
// After migrating to official SDK, update signature
func extractContextString(req *mcp.CallToolRequest, key string) string {
    // Adjust based on official SDK structure
    if val, ok := req.Params.Arguments[key]; ok {
        if str, ok := val.(string); ok {
            return str
        }
    }
    return ""
}

// Add helper to extract all context at once
func extractAllContext(req *mcp.CallToolRequest) map[string]string {
    return map[string]string{
        "tool_call_id":    extractContextString(req, "tool_call_id"),
        "request_id":      extractContextString(req, "request_id"),
        "conversation_id": extractContextString(req, "conversation_id"),
        "user_id":         extractContextString(req, "user_id"),
    }
}
```

#### Task 3.3.3: Tool Handler Logging Updates (Both Flows)
**Apply to:** `serper_mcp.go`, `memory_mcp.go`, `sandboxfusion_mcp.go`, etc.

**Current pattern:**
```go
// Extract context fields for logging and tracing
toolCallID := extractContextString(req, "tool_call_id")
requestID := extractContextString(req, "request_id")
conversationID := extractContextString(req, "conversation_id")
userID := extractContextString(req, "user_id")

// Log tool call with context
log.Info().
    Str("tool", "google_search").
    Str("tool_call_id", toolCallID).
    Str("request_id", requestID).
    Str("conversation_id", conversationID).
    Str("user_id", userID).
    Msg("MCP tool call received")
```

**Enhancement (use helper):**
```go
func handleTool(ctx context.Context, req *mcp.CallToolRequest, input InputType) (
    *mcp.CallToolResult,
    OutputType,
    error,
) {
    startTime := time.Now()
    
    // Extract all context at once
    context := extractAllContext(req)
    
    // Structured logging with all IDs
    log.Info().
        Str("tool", "tool_name").
        Str("tool_call_id", context["tool_call_id"]).
        Str("request_id", context["request_id"]).
        Str("conversation_id", context["conversation_id"]).
        Str("user_id", context["user_id"]).
        Msg("MCP tool execution started")
    
    // ... tool execution logic ...
    
    log.Info().
        Str("tool", "tool_name").
        Str("tool_call_id", context["tool_call_id"]).
        Int64("duration_ms", time.Since(startTime).Milliseconds()).
        Msg("MCP tool execution completed")
    
    return nil, output, nil
}
```
Notes:
- Convert non-string IDs with `fmt.Sprint` before logging to avoid panics.
- Keep handlers nil-safe; short-circuit if `req.Params` or `req.Params.Arguments` is nil.

#### Task 3.3.4: Frontend Enhancement (Optional - Flow 1 Only)
**File:** Frontend tool execution code (if accessible)

**Optional Enhancement:**
When calling MCP-Tools directly from frontend, could add header:
```typescript
// When executing tool from frontend
const response = await fetch('/v1/mcp', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-Tool-Call-ID': toolCall.id, // Optional: for better tracing
        'X-Request-ID': generateRequestId(),
    },
    body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'tools/call',
        params: {
            name: toolCall.function.name,
            arguments: JSON.parse(toolCall.function.arguments),
        },
    }),
});
```

**MCP-Tools would need to extract from header:**
```go
// In mcp_route.go serveMCP function
toolCallID := reqCtx.GetHeader("X-Tool-Call-ID")
if toolCallID != "" {
    ctx := context.WithValue(reqCtx.Request.Context(), "tool_call_id", toolCallID)
    reqCtx.Request = reqCtx.Request.WithContext(ctx)
}
```

**Note:** This is OPTIONAL since tool_call_id is already in the message content sent to LLM-API.

---

## Phase 4: Testing & Validation

### 5.1 Unit Tests
**Files to create:**
- [ ] `services/mcp-tools/internal/interfaces/httpserver/routes/mcp/mcp_route_test.go`

**Test cases:**
- Tool registration and discovery
- Context propagation (tool_call_id, request_id, etc.)
- HTTP SSE handler: happy path, invalid method/params, client disconnect, heartbeat timeout
- Error handling and graceful degradation

### 5.2 Integration Tests
**Scenarios:**
1. **Tool Call Round Trip:**
   - LLM generates tool call with tool_call_id
   - Frontend sends to response-api with X-Tool-Call-ID header
   - MCP-tools executes with context
   - Result returns with tool_call_id
   - LLM-API stores and retrieves correctly

2. **Conversation Reload:**
   - Create conversation with tool calls
   - Reload conversation
   - Verify tool_calls and tool_call_id restored
   - Verify proper message ordering

3. **Multiple Parallel Tools:**
   - Send 3 tool results simultaneously
   - Verify all 3 stored (not just last one)
   - Verify proper ordering and tool_call_id linking
4. **Transport Failures:**
   - Drop connection mid-call and confirm graceful cleanup/logging
   - Send malformed JSON-RPC and expect structured error response

### 5.3 Migration Validation Checklist
- [ ] All tools from mark3labs SDK migrated to official SDK
- [ ] HTTP transport working (SSE streaming)
- [ ] Context propagation functional (tool_call_id + request_id + conversation_id + user_id)
- [ ] All existing tools still functional:
  - [ ] google_search
  - [ ] scrape
  - [ ] file_search_index
  - [ ] file_search_query
  - [ ] python_exec (sandbox)
  - [ ] memory_retrieve
- [ ] External MCP providers still working (ProviderMCP)
- [ ] Logging includes all context fields
- [ ] No performance degradation
- [ ] Build successful: `make build-mcp-tools`
- [ ] Docker build successful: `make build-all`

### Phase 4 Checklist
- [ ] Implement unit tests for MCP server init, tool registration, and context propagation.
- [ ] Implement HTTP/SSE handler tests (happy path, invalid method/params, disconnects, heartbeats).
- [ ] Implement integration tests for tool_call_id round trips, reloads, and parallel calls.
- [ ] Validate migration checklist items and run `make build-mcp-tools` / `make build-all`.

---

## Phase 5: Documentation Updates

### 6.1 Developer Documentation
**Files to update:**
- [ ] `services/mcp-tools/README.md` - Update with official SDK references
- [ ] `services/mcp-tools/docs/CONTEXT_PROPAGATION.md` - NEW: Explain tool_call_id flow

### 6.2 API Documentation
**Update Swagger:**
- [ ] Document X-Tool-Call-ID header in response-api
- [ ] Document tool_call_id in request/response payloads

### 6.3 Migration Guide
**Create:** `services/mcp-tools/docs/MIGRATION_FROM_MARK3LABS.md`

Topics:
- Breaking changes between SDKs
- Code migration patterns
- Tool handler signature changes
- Context extraction updates
- HTTP transport implementation

### Phase 5 Checklist
- [ ] Refresh `services/mcp-tools/README.md` with official SDK usage and transport details.
- [ ] Add `services/mcp-tools/docs/CONTEXT_PROPAGATION.md`.
- [ ] Add `services/mcp-tools/docs/MIGRATION_FROM_MARK3LABS.md`.
- [ ] Update Swagger/API docs for `X-Tool-Call-ID` and context fields in payloads.

---

## Phase 6: Rollout Plan

### 7.1 Development Environment
1. Create feature branch: `feat/mcp-sdk-upgrade`
2. Implement changes incrementally:
   - Week 1: Dependency update + server initialization
   - Week 2: Tool registration migration + HTTP transport
   - Week 3: Context propagation enhancements + tests
3. Run tests continuously
4. Fix issues as they arise

### 7.2 Staging Deployment
1. Deploy to staging environment
2. Run comprehensive integration tests
3. Monitor logs for context propagation
4. Test all tool executions
5. Verify conversation reload scenarios
6. Performance benchmarking

### 7.3 Production Rollout
1. Deploy during low-traffic window
2. Monitor error rates and latency
3. Verify tool_call_id correlation in logs
4. Run smoke tests on critical tools
5. Gradual rollout with canary deployment (optional)
6. Rollback plan ready

### Phase 6 Checklist
- [ ] Complete feature branch work and code reviews for MCP SDK migration.
- [ ] Deploy to staging and run integration/performance tests with context tracing.
- [ ] Monitor staging logs/metrics for transport stability and context propagation.
- [ ] Execute production rollout with smoke tests and defined rollback.

---

## Phase 7: Future Enhancements

### 8.1 Tool Call Analytics
- Track tool execution success/failure rates by tool_call_id
- Measure tool latency and performance
- Correlation analysis (which tools are often used together)

### 8.2 Tool Call Retry Logic
- Implement automatic retry for failed tool calls
- Maintain tool_call_id across retries
- Exponential backoff strategy

### 8.3 Tool Call Caching
- Cache tool results by normalized inputs
- Use tool_call_id for cache invalidation
- TTL-based expiration

### Phase 7 Checklist
- [ ] Define metrics schema for tool call analytics (success/failure, latency) keyed by tool_call_id.
- [ ] Design retry strategy with tool_call_id preservation and backoff configuration.
- [ ] Prototype tool result caching approach and invalidation strategy.

## Appendix A: File Modification Summary

### Critical Files to Modify

| File | Changes | Priority | Flow |
|------|---------|----------|------|
| `go.mod` (mcp-tools) | Replace mark3labs dependency | P0 | Both |
| `mcp_route.go` | Server init + HTTP handler | P0 | Both |
| `serper_mcp.go` | Tool registration pattern + logging | P0 | Both |
| `memory_mcp.go` | Tool registration pattern + logging | P0 | Both |
| `sandboxfusion_mcp.go` | Tool registration pattern + logging | P0 | Both |
| `provider_mcp.go` | Tool registration pattern | P0 | Both |
| `context_utils.go` (mcp-tools) | Request structure changes + extractAllContext | P0 | Both |
| `client.go` (response-api mcp) | Enhanced logging with tool_call_id | P1 | Flow 2 |
| `chat_handler.go` (llm-api) | Already fixed âœ… | Done | Both |

### Files Already Fixed (Phase 3)

| File | What Was Fixed | Flow |
|------|---------------|------|
| `chat_handler.go` (llm-api) | `itemToMessage()` restores tool_calls and tool_call_id | Both |
| `chat_handler.go` (llm-api) | `buildInputConversationItems()` stores ALL messages | Both |
| `response_handler.go` (response-api) | X-Request-ID extraction and context injection | Flow 2 |
| `orchestrator.go` (response-api) | Passes RequestID, ConversationID, UserID to MCP | Flow 2 |
| `client.go` (response-api mcp) | CallRequest includes ToolCallID, RequestID, etc. | Flow 2 |

### New Files to Create

| File | Purpose | Priority | Flow |
|------|---------|----------|------|
| `docs/MIGRATION_FROM_MARK3LABS.md` | Migration guide | P3 | Both |
| `docs/CONTEXT_PROPAGATION.md` | Context flow documentation | P3 | Both |

---

## Appendix B: Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Official SDK API incompatibility | High | Medium | Thorough testing, read SDK docs carefully |
| HTTP transport complexity | Medium | High | Implement custom handler, test thoroughly |
| Context propagation breaks | High | Low | Already partially implemented, extend carefully |
| Breaking changes in production | High | Low | Comprehensive testing, staged rollout |
| External provider integration breaks | Medium | Medium | Test with actual MCP providers, fallback logic |

---

## Appendix C: Success Metrics

### Technical Metrics
- [ ] 100% tool migration (all mark3labs tools working with official SDK)
- [ ] Context propagation: tool_call_id present in >99% of tool executions
- [ ] Conversation reload: tool_call_id correctly restored in 100% of cases
- [ ] Multiple tool results: All tool results stored (not just last)
- [ ] HTTP SSE transport: <1% connection errors under load, heartbeats observed
- [ ] Build time: No significant regression (<5% increase)
- [ ] Test coverage: >80% for new code

### Operational Metrics
- [ ] Zero critical bugs in production after 1 week
- [ ] Tool execution latency: <10% increase
- [ ] Error rate: <1% increase
- [ ] Log volume: Context fields present without spam

---

## Appendix D: Architecture Decisions (from mcp-refactor-todo)

### D.1 Standalone MCP Server Option
**Decision:** Consider whether to extract MCP into a standalone process.

**Standalone Entrypoint Option:**
- New entrypoint: `cmd/mcp-server/main.go` with bootstrap (config load, logger, DI wiring, HTTP router)
- Reuse existing `infrastructure_provider` to construct search client/services
- Expose HTTP listener dedicated to MCP (port/env driven)
- Keeps MCP concerns isolated from main API server

**Current Decision:** Standalone MCP server remains in `mcp-tools` service; do not package inside `llm-api`.

### D.2 Authentication & Authorization
**Decision:** Auth/JWT is required for MCP calls.
- Propagate `user_id` into context so we can correlate tool calls with llm-api conversations
- Port `InjectUserContext` (JWT â†’ context user_id) but allow anonymous execution if token absent
- This aligns with the context propagation work in Phase 3

### D.3 TLS Termination
**Decision:** Prefer termination at the ingress/gateway (managed certs, simpler ops).
- If direct exposure is required (no front proxy), enable in-process TLS with autocert or provided cert/key
- Ensure SSE works over HTTPS
- Document the chosen termination point

### D.4 Configuration Surface
**MCP Server Environment Variables:**
| Variable | Description | Default |
|----------|-------------|---------|
| `MCP_SERVER_PORT` | Port for MCP HTTP listener | 8080 |
| `MCP_SERVER_HOST` | Host binding | 0.0.0.0 |
| `MCP_SERVER_LOG_LEVEL` | Log verbosity | info |

**Serper Variables (existing):**
- `SERPER_API_KEY`, `SERPER_CB_*`, `SERPER_RETRY_*`
- `SERPER_OFFLINE_MODE`, `SERPER_LOCATION_HINT`, domain filters
- Fail fast on missing `SERPER_API_KEY` unless `SERPER_OFFLINE_MODE=true`

### D.5 HTTP Middleware Concerns
**Security & Reliability:**
- Body size limits to avoid abuse (e.g., 1MB max request body)
- Request timeouts (e.g., 30s for tool execution, 60s for SSE connection)
- Optional CORS if browser clients will call the endpoint directly
- Logging and request IDs for traceability (integrates with Phase 3 context propagation)

### D.6 Error Handling Contract
**JSON-RPC Error Codes:**
| Scenario | Code | Message |
|----------|------|---------|
| Unknown method | -32601 | Method not found |
| Invalid params | -32602 | Invalid params |
| Circuit breaker open | -32001 | Server temporarily unavailable |
| Missing API key | -32602 | Invalid params (missing required config) |
| Internal error | -32603 | Internal error |

**Error Response Structure:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32001,
    "message": "Server temporarily unavailable",
    "data": {
      "reason": "circuit_breaker_open",
      "retry_after_ms": 5000
    }
  }
}
```

### D.7 Migration Path
**Incremental Transition:**
1. Keep existing `/v1/mcp` route temporarily
2. Add env flag (e.g., `MCP_USE_NEW_TRANSPORT=true`) to direct traffic to new implementation
3. Document the new endpoint and required params
4. Note that only Serper tools are initially tested with new transport
5. Plan future phases to add provider/sandbox/memory tools validation

---

## Timeline Estimate

| Phase | Duration | Dependencies |
|-------|----------|--------------|
| Phase 1: Assessment | 2 days | None |
| Phase 2: Migration | 5 days | Phase 1 |
| Phase 3: Tracking | 3 days | Phase 2 |
| Phase 4: Testing | 3 days | Phases 2-3 |
| Phase 5: Documentation | 2 days | Phases 2-4 |
| Phase 6: Rollout | 2 days | Phase 4 |
| **Total** | **22 days** (~4.5 weeks) | |

**Buffer:** Add 20% (4-5 days) for unexpected issues = **~5-6 weeks total**

---

## Next Steps

1. **Review this plan** with team for feedback
2. **Create feature branch** and set up development environment
3. **Start with Phase 2.1** (dependency update) to validate SDK compatibility
4. **Implement incrementally** following the phases
5. **Test continuously** after each change
6. **Document as you go** to avoid documentation debt

---

**Last Updated:** December 13, 2025  
**Author:** AI Assistant  
**Status:** Draft - Awaiting Review  
**Note:** Merged architecture decisions from `mcp-refactor-todo.md` into Appendix D
