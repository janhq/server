---
title: Security
description: Security architecture and best practices
full: false
---

# Security Architecture

Jan Server uses Kong + Keycloak at the edge with service-level JWT validation to keep internal APIs isolated.

## Identity & Access

- **Keycloak (OAuth2/OIDC)** issues all JWTs via the `jan` realm. Services rely on `AUTH_ENABLED`, `AUTH_ISSUER`, and `AUTH_JWKS_URL` env vars to validate tokens.
- **Kong gateway (http://localhost:8000)** protects `/llm/*`, `/responses/*`, `/media/*`, and `/mcp/*` routes using:
  - `jwt` plugin: validates Keycloak tokens, injects user headers (`X-User-Id`, `X-User-Email`, `X-Auth-Method`).
  - `keycloak-apikey` plugin: forwards `X-API-Key` to `LLM API /auth/validate-api-key`, hides credentials from upstream services, and supports per-key rate limits.
- **Guest login** (`POST /llm/auth/guest-login`) creates temporary Keycloak users for local testing; upgrade via `/auth/upgrade` for permanent accounts.
- **API key lifecycle** lives inside LLM API (`/auth/api-keys` CRUD). Secrets are hashed with SHA-256 and stored as Keycloak attributes.

## Network Boundaries

- **Public**: Kong (8000) and optional Keycloak admin (8085) behind VPN/SSO.
- **Private**: LLM API (8080), Response API (8082), Media API (8285), MCP Tools (8091), vLLM (8101).
- **MCP-only network**: SearXNG, Redis, Vector Store, SandboxFusion run on `jan-server_mcp-network` and are never exposed externally.
- **Kubernetes**: enforce NetworkPolicies or service mesh rules that mimic the Compose network split.

## Data Protection

- PostgreSQL containers run inside the Compose network; production should use managed instances with TLS enforced.
- S3 credentials live in `config/secrets.env` (git-ignored) or secret managers; Media API mounts them directly.
- `jan_*` identifiers act as opaque references; presigned URLs are generated on demand and expire quickly.
- Structured logging removes sensitive headers; Kong strips tokens before proxying when `hide_credentials=true`.

## Secrets Lifecycle

1. Add new variables to `.env.template` with inline comments.
2. Mirror them in `config/secrets.env.example` to keep templates consistent.
3. Document expected usage in this doc plus the relevant service README.
4. Load secrets in production from secret managers (AWS Secrets Manager, GCP Secret Manager, Kubernetes secrets) instead of raw `.env` files.

## Threat Mitigations

- **JWT validation**: services reject expired tokens and refresh JWKS caches periodically.
- **Tool execution**: SandboxFusion isolates python execution; `SANDBOX_FUSION_REQUIRE_APPROVAL` can require human approval.
- **Web fetches**: SearXNG/Serper output is filtered through Response API budgets so workflows cannot recurse forever.
- **Media uploads**: Media API enforces Bearer authentication plus `MEDIA_MAX_BYTES`, content-type validation, and deduplication.
- **Rate limiting**: Configure Kong plugins per route; Response API applies internal throttles on long-running workflows.

## Incident Response

- Capture `X-Request-ID`/`Traceparent` headers from responses to correlate requests across Kong, services, and observability tools.
- Use Jaeger and Grafana dashboards (via `make monitor-up`) for triage.
- Rotate API keys via LLM API endpoints and restart Kong if Keycloak signing keys change.

See also: [Authentication Guide](/docs/guides/authentication), [Deployment Guide](/docs/guides/deployment), and [Configuration Overview](/docs/configuration/overview).
