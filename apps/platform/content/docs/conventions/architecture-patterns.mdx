---
title: Architecture & Structure
description: Repository layout and clean-architecture guidelines.
full: false
---

# Architecture & Structure Conventions

Use this reference to understand how Jan Server is organised. Every example maps directly to the `jan-server` repository.

## Repository Layout (Top Level)

```
jan-server/
+-- cmd/jan-cli/                # jan-cli sources + wrappers
+-- config/                     # Shared configuration defaults and templates
+-- docker/                     # Compose fragments (infra, services, observability)
+-- docs/                       # Documentation (guides, conventions, templates)
+-- k8s/                        # Helm chart + Kubernetes manifests
+-- services/
    +-- llm-api/
    +-- media-api/
    +-- response-api/
    +-- mcp-tools/
    +-- template-api/
+-- tests/                      # jan-cli api-test collections
+-- Makefile                    # Canonical automation entry point
+-- docker-compose.yml          # Root compose file wired to profiles
+-- docker-compose.dev-full.yml # Dev-Full overrides (host routing)
```

Each service folder follows the same structure:

```
services/<service>/
+-- cmd/
    +-- server/                 # Service entrypoint
    +-- gormgen/                # (llm-api) schema generator
+-- config/                     # Service-specific configuration helpers
+-- internal/
    +-- domain/                 # Business logic (no HTTP/DB imports)
    +-- infrastructure/         # Repositories, cache, provider clients
    +-- interfaces/httpserver/  # Gin routes, requests, responses, middleware
+-- migrations/                 # SQL migrations
+-- swagger/ or docs/swagger/   # Generated OpenAPI files
+-- scripts/                    # Service utilities (optional)
+-- Makefile                    # Service-local helpers (e.g., `make gormgen`)
+-- go.mod / go.sum             # Module definition
```

## Clean Architecture Layers

```
Interfaces (routes, cron, event consumers)
        ->
Domain (entities, services, validation)
        ->
Infrastructure (repositories, cache, providers)
```

**Rules:**
- Domain packages only import other domain packages plus injected interfaces (for example repository interfaces).
- Infrastructure implements those interfaces and may import external drivers (PostgreSQL, Redis, provider SDKs, etc.).
- Interfaces (HTTP) bind requests to domain services. Avoid placing business logic inside Gin handlers.

## File Placement Cheat Sheet

| Task | Location | Example |
|------|----------|---------|
| New domain aggregate | `services/<svc>/internal/domain/<aggregate>/` | `services/llm-api/internal/domain/conversation/` |
| New HTTP endpoint | `services/<svc>/internal/interfaces/httpserver/routes/<area>/` | `services/llm-api/internal/interfaces/httpserver/routes/v1/conversations/` |
| New schema/table | `services/<svc>/internal/infrastructure/database/dbschema/` |
| Repository implementation | `services/<svc>/internal/infrastructure/database/repository/<name>/` |
| Cache/provider client | `services/<svc>/internal/infrastructure/<provider>/` |
| Shared helper | `services/<svc>/internal/utils/<category>/` |

### Domain Entity Package

```
services/<svc>/internal/domain/<entity>/
+-- <entity>.go            # Entity struct + methods
+-- service.go             # Business logic/orchestrations
+-- filter.go              # Query filters (optional)
+-- dto.go                 # Converters if needed
```

### Infrastructure Repository Package

```
services/<svc>/internal/infrastructure/database/
+-- dbschema/              # Schema structs + EtoD/DToE helpers
+-- repository/
    +-- <entity>repo/      # Repository implementation
+-- gormgen/               # Generated query builders (llm-api)
```

### HTTP Interface Package

```
services/<svc>/internal/interfaces/httpserver/
+-- routes/v1/<group>/     # Route registration + handlers
+-- requests/<group>/      # Request DTOs + validation
+-- responses/<group>/     # Response DTOs
+-- middlewares/           # Shared middleware
```

## When to Add New Packages

1. **New domain concept**? Create `internal/domain/<concept>` with entity + service.
2. **New transport handler**? Add routes under `internal/interfaces/httpserver/routes/v1/<area>` plus matching `requests/` and `responses/`.
3. **New persistence logic**? Add schema files under `dbschema/` and repositories under `repository/<concept>repo/`, then run `make gormgen`.
4. **New provider client**? Add package under `internal/infrastructure/<provider>/` and inject via constructors.

## Anti-Patterns to Avoid

- Direct DB access from handlers-always go through domain services.
- Fat handlers-route handlers should validate input, call domain services, and return responses.
- Stashing business logic in `internal/utils`-keep helpers generic, domain rules stay in domain packages.
- Creating interfaces "just in case"-add them when multiple implementations or tests require it.

## Quick Layer Checklist

- Domain packages only import standard library + other domain packages.
- Infrastructure packages never import HTTP routes.
- Requests/responses convert to domain types immediately (`req.ToDomain()` etc.).
- GORM pointer rules enforced in `dbschema/` structs.

See [Code Patterns & Best Practices](/docs/conventions/design-patterns) for concrete examples and [Development Workflow](/docs/conventions/workflow) for the commands that keep code generation/testing in sync.
