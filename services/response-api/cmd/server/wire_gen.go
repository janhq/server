// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/google/wire"
	"github.com/rs/zerolog"
	"gorm.io/gorm"
	logger2 "gorm.io/gorm/logger"
	"jan-server/services/response-api/internal/config"
	artifactdomain "jan-server/services/response-api/internal/domain/artifact"
	conversation2 "jan-server/services/response-api/internal/domain/conversation"
	"jan-server/services/response-api/internal/domain/llm"
	plandomain "jan-server/services/response-api/internal/domain/plan"
	response2 "jan-server/services/response-api/internal/domain/response"
	"jan-server/services/response-api/internal/domain/tool"
	"jan-server/services/response-api/internal/infrastructure/auth"
	"jan-server/services/response-api/internal/infrastructure/database"
	"jan-server/services/response-api/internal/infrastructure/llmprovider"
	"jan-server/services/response-api/internal/infrastructure/logger"
	"jan-server/services/response-api/internal/infrastructure/mcp"
	artifactrepo "jan-server/services/response-api/internal/infrastructure/repository/artifact"
	"jan-server/services/response-api/internal/infrastructure/repository/conversation"
	planrepo "jan-server/services/response-api/internal/infrastructure/repository/plan"
	"jan-server/services/response-api/internal/infrastructure/repository/response"
	"jan-server/services/response-api/internal/interfaces/httpserver"
	"jan-server/services/response-api/internal/webhook"
)

// Injectors from wire.go:

// BuildApplication demonstrates how to assemble the response service with Wire.
func BuildApplication(ctx context.Context) (*Application, error) {
	configConfig, err := config.Load()
	if err != nil {
		return nil, err
	}
	zerologLogger := logger.New(configConfig)
	databaseConfig := newDatabaseConfig(configConfig)
	db, err := newGormDB(ctx, databaseConfig, zerologLogger)
	if err != nil {
		return nil, err
	}
	postgresRepository := response.NewPostgresRepository(db)
	postgresRepository2 := planrepo.NewPostgresRepository(db)
	postgresRepository3 := artifactrepo.NewPostgresRepository(db)
	repository := conversation.NewRepository(db)
	itemRepository := conversation.NewItemRepository(db)
	client := newLLMProvider(configConfig)
	mcpClient := newMCPClient(configConfig)
	orchestrator := newOrchestrator(configConfig, client, mcpClient)
	httpService := newWebhookService(zerologLogger)
	service := newResponseService(postgresRepository, repository, itemRepository, postgresRepository, orchestrator, mcpClient, client, httpService, zerologLogger)
	service2 := plandomain.NewService(postgresRepository2)
	service3 := artifactdomain.NewService(postgresRepository3)
	validator, err := newAuthValidator(ctx, configConfig, zerologLogger)
	if err != nil {
		return nil, err
	}
	httpServer := httpserver.New(configConfig, zerologLogger, service, service2, service3, validator)
	application := NewApplication(httpServer, zerologLogger)
	return application, nil
}

// wire.go:

var responseSet = wire.NewSet(response.NewPostgresRepository, wire.Bind(new(response2.Repository), new(*response.PostgresRepository)), wire.Bind(new(response2.ToolExecutionRepository), new(*response.PostgresRepository)), planrepo.NewPostgresRepository, wire.Bind(new(plandomain.Repository), new(*planrepo.PostgresRepository)), artifactrepo.NewPostgresRepository, wire.Bind(new(artifactdomain.Repository), new(*artifactrepo.PostgresRepository)), conversation.NewRepository, wire.Bind(new(conversation2.Repository), new(*conversation.Repository)), conversation.NewItemRepository, wire.Bind(new(conversation2.ItemRepository), new(*conversation.ItemRepository)), newLLMProvider, wire.Bind(new(llm.Provider), new(*llmprovider.Client)), newMCPClient, wire.Bind(new(tool.MCPClient), new(*mcp.Client)), newOrchestrator,
	newWebhookService, wire.Bind(new(webhook.Service), new(*webhook.HTTPService)), newResponseService, plandomain.NewService, artifactdomain.NewService,
)

func newDatabaseConfig(cfg *config.Config) database.Config {
	return database.Config{
		DSN:             cfg.GetDatabaseWriteDSN(),
		MaxIdleConns:    cfg.DBMaxIdleConns,
		MaxOpenConns:    cfg.DBMaxOpenConns,
		ConnMaxLifetime: cfg.DBConnLifetime,
		LogLevel:        logger2.Warn,
	}
}

func newGormDB(ctx context.Context, cfg database.Config, log zerolog.Logger) (*gorm.DB, error) {
	db, err := database.Connect(cfg)
	if err != nil {
		return nil, err
	}
	if err := database.AutoMigrate(ctx, db, log); err != nil {
		return nil, err
	}
	return db, nil
}

func newAuthValidator(ctx context.Context, cfg *config.Config, log zerolog.Logger) (*auth.Validator, error) {
	return auth.NewValidator(ctx, cfg, log)
}

func newLLMProvider(cfg *config.Config) *llmprovider.Client {
	return llmprovider.NewClient(cfg.LLMAPIURL)
}

func newMCPClient(cfg *config.Config) *mcp.Client {
	return mcp.NewClient(cfg.MCPToolsURL)
}

func newOrchestrator(cfg *config.Config, provider llm.Provider, mcpClient tool.MCPClient) *tool.Orchestrator {
	return tool.NewOrchestrator(provider, mcpClient, cfg.MaxToolDepth, cfg.ToolTimeout)
}

func newWebhookService(log zerolog.Logger) *webhook.HTTPService {
	return webhook.NewHTTPService(log)
}

func newResponseService(
	repo response2.Repository,
	conversations conversation2.Repository,
	conversationItems conversation2.ItemRepository,
	toolRepo response2.ToolExecutionRepository,
	orchestrator *tool.Orchestrator,
	mcpClient tool.MCPClient,
	modelInfoProvider llm.ModelInfoProvider,
	webhookService webhook.Service,
	log zerolog.Logger,
) response2.Service {
	return response2.NewService(repo, conversations, conversationItems, toolRepo, orchestrator, mcpClient, modelInfoProvider, webhookService, log)
}
