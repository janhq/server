{
  "info": {
    "name": "MCP Tools & SearXNG Smoke",
    "description": "Guest auth + MCP tools listing/search/scrape plus direct SearXNG checks.",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "llm_api_url",
      "value": "http://localhost:8080"
    },
    {
      "key": "mcp_tools_url",
      "value": "http://localhost:8091"
    },
    {
      "key": "searxng_url",
      "value": "http://localhost:8086"
    },
    {
      "key": "guest_access_token",
      "value": ""
    }
  ],
  "item": [
    {
      "name": "Guest Auth",
      "item": [
        {
          "name": "Request Guest Token",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{}"
            },
            "url": "{{llm_api_url}}/auth/guest-login"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const guestData = pm.response.json();",
                  "pm.test('Guest token issued', function () {",
                  "  pm.response.to.have.status(201);",
                  "  pm.expect(guestData).to.have.property('access_token');",
                  "  pm.collectionVariables.set('guest_access_token', guestData.access_token);",
                  "});",
                  "pm.test('Response includes expiry', function () {",
                  "  pm.expect(guestData).to.have.property('expires_in');",
                  "});"
                ]
              }
            }
          ]
        },
        {
          "name": "MCP Search Domain Filter",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"google_search\",\n    \"arguments\": {\n      \"q\": \"Example Domain\",\n      \"domain_allow_list\": [\"example.com\"]\n    }\n  },\n  \"id\": 4\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse structured search payload', err);",
                  "}",
                  "pm.test('Domain filter enforces example.com citations', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured.results).to.be.an('array');",
                  "  pm.expect(structured.results.length).to.be.greaterThan(0);",
                  "  structured.results.forEach((res) => pm.expect(res.source_url).to.include('example.com'));",
                  "});"
                ]
              }
            }
          ]
        },
        {
          "name": "MCP Search Offline Mode",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"google_search\",\n    \"arguments\": {\n      \"q\": \"offline mode smoke test\",\n      \"offline_mode\": true\n    }\n  },\n  \"id\": 5\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse structured search payload', err);",
                  "}",
                  "pm.test('Offline mode returns cache status and non-live flag', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured.cache_status).to.match(/offline|fallback/);",
                  "  pm.expect(structured.live).to.eql(false);",
                  "});"
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "MCP Tools",
      "item": [
        {
          "name": "List MCP Tools",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/list\",\n  \"id\": 1\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.variables.set('mcp_payload', JSON.stringify(payload || {}));",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "pm.test('Parsed MCP payload', function () {",
                  "  pm.expect(payload).to.be.an('object');",
                  "});",
                  "const parsed = payload && payload.result && payload.result.tools ? payload.result.tools : [];",
                  "pm.test('Tools list returned', function () {",
                  "  pm.expect(parsed.length).to.be.greaterThan(0);",
                  "});",
                  "pm.collectionVariables.set('mcp_tool_count', parsed.length);"
                ]
              }
            }
          ]
        },
        {
          "name": "Serper Search via MCP",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"google_search\",\n    \"arguments\": {\n      \"q\": \"Model Context Protocol\"\n    }\n  },\n  \"id\": 2\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.variables.set('mcp_payload', JSON.stringify(payload || {}));",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "pm.test('Parsed MCP payload', function () {",
                  "  pm.expect(payload).to.be.an('object');",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "pm.test('Search payload contains structured text', function () {",
                  "  pm.expect(textBlock).to.exist;",
                  "  pm.expect(textBlock.text.length).to.be.greaterThan(0);",
                  "});",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse structured search payload', err);",
                  "}",
                  "pm.test('Structured search payload has results and citations', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured.results).to.be.an('array');",
                  "  pm.expect(structured.results.length).to.be.greaterThan(0);",
                  "  pm.expect(structured.results[0]).to.have.property('source_url');",
                  "  pm.expect(structured.results[0]).to.have.property('cache_status');",
                  "  pm.expect(structured).to.have.property('citations');",
                  "});"
                ]
              }
            }
          ]
        },
        {
          "name": "Serper Scrape via MCP",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"scrape\",\n    \"arguments\": {\n      \"url\": \"https://example.com\"\n    }\n  },\n  \"id\": 3\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.variables.set('mcp_payload', JSON.stringify(payload || {}));",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "pm.test('Parsed MCP payload', function () {",
                  "  pm.expect(payload).to.be.an('object');",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "pm.test('Scrape payload contains structured text', function () {",
                  "  pm.expect(textBlock).to.exist;",
                  "  pm.expect(textBlock.text.length).to.be.greaterThan(0);",
                  "});",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse structured scrape payload', err);",
                  "}",
                  "pm.test('Structured scrape payload exposes preview and cache status', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured).to.have.property('text');",
                  "  pm.expect(structured).to.have.property('text_preview');",
                  "  pm.expect(structured).to.have.property('cache_status');",
                  "});",
                  "pm.test('Scrape payload mentions example.com', function () {",
                  "  pm.expect(structured && structured.text).to.include('Example Domain');",
                  "});"
                ]
              }
            }
          ]
        },
        {
          "name": "File Search Index",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"file_search_index\",\n    \"arguments\": {\n      \"document_id\": \"postman-doc-1\",\n      \"text\": \"Postman MCP automation smoke guide covering Model Context Protocol flows.\",\n      \"metadata\": {\n        \"category\": \"kb\",\n        \"version\": \"1.0\"\n      },\n      \"tags\": [\"automation\", \"kb\"]\n    }\n  },\n  \"id\": 6\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse structured indexing payload', err);",
                  "}",
                  "pm.test('Vector store returned indexed status', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured.status || structured.Status).to.be.oneOf(['indexed', 'created']);",
                  "});",
                  "pm.collectionVariables.set('file_doc_id', 'postman-doc-1');"
                ]
              }
            }
          ]
        },
        {
          "name": "File Search Query",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"file_search_query\",\n    \"arguments\": {\n      \"query\": \"automation smoke\",\n      \"top_k\": 3,\n      \"document_ids\": [\"postman-doc-1\"]\n    }\n  },\n  \"id\": 7\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse structured search payload', err);",
                  "}",
                  "pm.test('Vector search returns our indexed document', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured.results).to.be.an('array').that.is.not.empty;",
                  "  const first = structured.results[0];",
                  "  pm.expect(first.document_id).to.eql('postman-doc-1');",
                  "  pm.expect(first.text_preview).to.include('automation');",
                  "});"
                ]
              }
            }
          ]
        },
        {
          "name": "SandboxFusion Python Exec",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{guest_access_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"python_exec\",\n    \"arguments\": {\n      \"code\": \"print(\\\"hello from sandbox\\\")\",\n      \"language\": \"python\",\n      \"approved\": true\n    }\n  },\n  \"id\": 8\n}"
            },
            "url": "{{mcp_tools_url}}"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const rawBody = pm.response.text();",
                  "let payload = null;",
                  "try {",
                  "  payload = JSON.parse(rawBody);",
                  "} catch (err) {",
                  "  const lines = rawBody.split('\\n');",
                  "  for (const line of lines) {",
                  "    if (line.startsWith('data: ')) {",
                  "      try {",
                  "        payload = JSON.parse(line.substring(6));",
                  "        break;",
                  "      } catch (e) {",
                  "        console.error('Failed to parse SSE payload', e);",
                  "      }",
                  "    }",
                  "  }",
                  "}",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "const content = (payload && payload.result && payload.result.content) || [];",
                  "const textBlock = content.find((block) => block.type === 'text');",
                  "let structured = null;",
                  "try {",
                  "  structured = textBlock ? JSON.parse(textBlock.text) : null;",
                  "} catch (err) {",
                  "  console.error('Failed to parse sandboxfusion payload', err);",
                  "}",
                  "pm.test('SandboxFusion returned stdout', function () {",
                  "  pm.expect(structured).to.be.an('object');",
                  "  pm.expect(structured.stdout || '').to.include('hello from sandbox');",
                  "});"
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "SearXNG",
      "item": [
        {
          "name": "SearXNG HTML Search",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-Forwarded-For",
                "value": "127.0.0.1"
              },
              {
                "key": "X-Real-IP",
                "value": "127.0.0.1"
              },
              {
                "key": "User-Agent",
                "value": "PostmanRuntime/7.36"
              },
              {
                "key": "Accept",
                "value": "text/html"
              }
            ],
            "url": {
              "raw": "{{searxng_url}}/search?q=Model+Context+Protocol",
              "host": [
                "{{searxng_url}}"
              ],
              "path": [
                "search"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "Model Context Protocol"
                }
              ]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const searxHtml = pm.response.text();",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "pm.test('SearXNG page contains query text', function () {",
                  "  pm.expect(searxHtml).to.include('SearXNG');",
                  "});"
                ]
              }
            }
          ]
        },
        {
          "name": "SearXNG Text Scrape",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-Forwarded-For",
                "value": "127.0.0.1"
              },
              {
                "key": "X-Real-IP",
                "value": "127.0.0.1"
              },
              {
                "key": "User-Agent",
                "value": "PostmanRuntime/7.36"
              },
              {
                "key": "Accept",
                "value": "text/html"
              }
            ],
            "url": {
              "raw": "{{searxng_url}}/search?q=https://example.com",
              "host": [
                "{{searxng_url}}"
              ],
              "path": [
                "search"
              ],
              "query": [
                {
                  "key": "q",
                  "value": "https://example.com"
                }
              ]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const searxText = pm.response.text();",
                  "pm.test('Status code is 200', function () {",
                  "  pm.response.to.have.status(200);",
                  "});",
                  "pm.test('Body contains text', function () {",
                  "  pm.expect(searxText.length).to.be.greaterThan(0);",
                  "});"
                ]
              }
            }
          ]
        }
      ]
    }
  ]
}

